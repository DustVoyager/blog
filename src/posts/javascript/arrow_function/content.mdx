---
title: "Javascript arrow function"
desc: javascript arrow function 대해서 정리한 글입니다.
date: 2024-10-13
thumbnail: /posts/javascript.png
---

# 8. Arrow Function

## 8-1. 소개

```js
var a = function () {
  return new Date();
};
var b = function (a) {
  return a * a;
};
var c = function (a, b) {
  return a + b;
};
var d = function (a, b) {
  console.log(a * b);
};
```

```js
let a = () => new Date();
let b = (a) => a * a;
let c = (a, b) => a + b;
let d = (a, b) => {
  console.log(a * b);
};
```

## 8-2. 상세

#### 1) `(매개변수) => { 본문 }`

#### 2) 매개변수가 하나뿐인 경우 괄호 생략 가능

#### 3) 매개변수가 없을 경우엔 괄호 필수

#### 4) 본문이 `return [식 or 값]` 뿐인 경우 `{ }`와 `return` 키워드 생략 가능

#### 5) 위 4) 에서 return할 값이 `객체`인 경우엔 괄호 필수

```js
const f = () => {
  a: 1,
  b: 2
}

const f = () => ({
  a: 1,
  b: 2
})
```

#### 6) 실행컨텍스트 생성시 this 바인딩을 하지 않음

```js
const obj = {
  a: function () {
    console.log(this);

    const b = () => {
      console.log(this);
    };

    b();
  },
};
obj.a();
```

```js
const obj = {
  grades: [80, 90, 100],
  getTotal: function () {
    this.total = 0;
    this.grades.forEach(function (v) {
      this.total += v;
    });
  },
};
obj.getTotal();
console.log(obj.total);
```

#### 7) 명시적 this 바인딩 ?

```js
const a = () => {
  console.log(this);
};
a.call({ a: 1 });
```

```js
const a = (...rest) => {
  console.log(this, rest);
};
a.call({ a: 1 }, 1, 2, 3);
a.apply([], [4, 5, 6]);
const b = a.bind(null, 7, 8, 9, 10);
b();
```

```js
const obj = {
  f() {
    const a = (...rest) => {
      console.log(this, rest);
    };
    a.call({ a: 1 }, 1, 2, 3);
    a.apply([], [4, 5, 6]);
    const b = a.bind(null, 7, 8, 9, 10);
    b();
  },
};
obj.f();
```

#### 8) 생성자함수로 ?

```js
const P = (name) => {
  this.name = name;
};
const j = new P("제니");

console.dir(P);
```

#### 9) 그밖에

this 외에도 super, arguments, new.target 등을 바인딩하지 않는다.

---

# 9. function - etc.

## 9-1. `name` property of function

```js
function a() {}
console.log(a.name);

const b = function () {};
console.log(b.name);

const c = function cc() {};
console.log(c.name);

const d = () => {};
console.log(d.name);

const e = {
  om1: function () {},
  om2() {},
  om3: () => {},
};
console.log(e.om1.name, e.om2.name, e.om3.name);

class F {
  static method1() {}
  method2() {}
}
const f = new F();
console.log(F.method1.name, f.method2.name);
```

```js
const g = new Function();
console.log(g.name);
```

```js
function a() {}
const b = function () {};
const h = a.bind(b);
console.log(h.name);
```

```js
const person = {
  _name: "jennie",
  get name() {
    return this._name;
  },
  set name(v) {
    this._name = v;
  },
};
const descriptor = Object.getOwnPropertyDescriptor(person, "name");
console.log(descriptor.get.name);
console.log(descriptor.set.name);
```

## 9-2. `new.target`

[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target]()

```js
function Person(name) {
  if (this instanceof Person) {
    this.name = name;
  } else {
    throw new Error("new 연산자를 사용하세요.");
  }
}
var p1 = new Person("제니");
console.log(p1);

var p2 = Person("성훈");
console.log(p2);

var p3 = Person.call({}, "푸들");
console.log(p3);

var p4 = Person.call(p1, "푸들");
console.log(p4);
```

```js
function Person(name) {
  console.dir(new.target);
  if (new.target !== undefined) {
    this.name = name;
  } else {
    throw new Error("new 연산자를 사용하세요.");
  }
}

const p1 = new Person("제니");
console.log(p1);

const p2 = Person("jennie");
console.log(p2);

const p3 = Person.call({}, "푸들");
console.log(p3);

const p4 = Person.call(p1, "푸들");
console.log(p4);
```

```js
function Person(name) {
  const af = (n) => {
    this.name = n;
    console.log(new.target);
  };
  af(name);
}
const p1 = new Person("제니");
const p2 = Person("성훈");
```

```js
function Person(name) {
  this.name = name;
}
function Android(name) {
  Person.call(this, name);
}
const p1 = new Android("환상의 디지털 제니");
```

```js
function Person(name) {
  console.log(new.target);
  if (new.target === Person) {
    this.name = name;
  } else {
    throw new Error("Person 생성자함수를 new로 호출해야 해요!");
  }
}
function Android(name) {
  Person.call(this, name);
}
const p2 = new Android("jennie");
```

## 9-3. 블록스코프 내에서의 함수 선언과 호이스팅 (브라우저 비교)

```js
if (true) {
  a();
  function a() {
    console.log(true);
  }
}
a();
```

```js
a();
if (true) {
  a();
  function a() {
    console.log(true);
  }
}
```

```js
if (true) {
  a();
  function a() {
    console.log(true);
  }
  if (true) {
    a();
    function a() {
      console.log(false);
    }
  }
}
a();
```

```js
"use strict";
if (true) {
  a();
  function a() {
    console.log(true);
  }
  if (true) {
    a();
    function a() {
      console.log(false);
    }
  }
}
a();
```

```js
"use strict";
if (true) {
  function a() {
    console.log(true);
  }
  a();
}
a();
```
